import os
import json
from typing import List, Any
from ..core.base_init import BaseInitAnalyzer
from ..models.package_info import ServiceMetadata

class DockerInitAnalyzer(BaseInitAnalyzer):
    """
    Analyzer for Docker Container Entrypoints.
    Reads .docker_info.json generated by DockerSource.
    """

    def detect(self, volume_path: str) -> bool:
        return os.path.exists(os.path.join(volume_path, ".docker_info.json"))

    def get_all_services(self, volume_path: str) -> List[ServiceMetadata]:
        # For Docker, "all services" is effectively the entrypoint config
        return self.get_startup_services(volume_path)

    def get_startup_services(self, volume_path: str) -> List[ServiceMetadata]:
        config_path = os.path.join(volume_path, ".docker_info.json")
        if not os.path.exists(config_path):
            return []
            
        try:
            with open(config_path, 'r') as f:
                info = json.load(f)
        except Exception:
            return []
            
        services = []
        
        # Entrypoint
        entrypoint = info.get("Entrypoint")
        cmd = info.get("Cmd")
        
        # Combine Entrypoint and Cmd
        # If both exist, Entrypoint is executable, Cmd is args.
        # If only Entrypoint, it's executable.
        # If only Cmd, it's executable.
        
        executables = []
        full_command = ""
        
        if entrypoint:
            # Entrypoint is list of strings
            executables.append(entrypoint[0])
            full_command += " ".join(entrypoint)
        
        if cmd and not entrypoint:
            executables.append(cmd[0])
            full_command += " ".join(cmd)
        elif cmd and entrypoint:
            full_command += " " + " ".join(cmd)
            
        # Create a "service" for the container entry
        if executables:
            services.append(ServiceMetadata(
                name="Docker Entrypoint",
                path="Dockerfile", # Abstract
                status="running",
                executables=executables,
                executable_names=[os.path.basename(e) for e in executables]
            ))
            
        return services

    def parse_service_executables(self, service_path: str) -> List[str]:
        # Not used directly as we parse JSON configuration
        return []
